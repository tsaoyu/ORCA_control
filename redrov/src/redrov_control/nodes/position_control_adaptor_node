#!/usr/bin/env python
import rospy
from nav_msgs.msg import Odometry
from std_msgs.msg import Float64
from geometry_msgs.msg import Twist, PoseStamped
import tf
import numpy as np
from math import sin, cos

class PositionControllerAdaptor():

    def __init__(self):

        self.transfomration_matrix = np.diag([1, 1, 1, 1, 1 ,1])

        self.odom_sub = rospy.Subscriber('/BodyROV01/odom', Odometry, self.odom_callback, queue_size=50)
        self.pose_sub = rospy.Subscriber('/pose_ref', PoseStamped, self.pose_callback, queue_size=10)
        self.dof_name = ["x", "y", "z", "phi", "theta", "psi"]
        
        self.state = {}
        self.state["x"] = float('nan')
        self.state["y"] = float('nan')
        self.state["z"] = float('nan')

        self.state["phi"] = float('nan')
        self.state["theta"] = float('nan')
        self.state["psi"]  = float('nan')

        self.pose_ref = {}
        self.pose_ref["x"] = float('nan')
        self.pose_ref["y"] = float('nan')
        self.pose_ref["z"] = float('nan')

        self.pose_ref["phi"] = float('nan')
        self.pose_ref["theta"] = float('nan')
        self.pose_ref["psi"]  = float('nan')


        self.pubs = {}
        for dof in self.dof_name:
            self.pubs[dof] = rospy.Publisher('/position_controllers/meas/{}'.format(dof), Float64, queue_size=10)
        # Publish measured position in body frame

        self.pose_pubs = {}
        for dof in self.dof_name:
            self.pose_pubs[dof] = rospy.Publisher('/position_controllers/setpoint/{}'.format(dof), Float64, queue_size=10)
        # Publish desired position in body frame


    def odom_callback(self, msg):

        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        z = msg.pose.pose.position.z

        quaternion = [msg.pose.pose.orientation.x, msg.pose.pose.orientation.y, msg.pose.pose.orientation.z, msg.pose.pose.orientation.w]
        phi, theta, psi = tf.transformations.euler_from_quaternion(quaternion, 'sxyz')

        self.transfomration_matrix = np.array(
         [[cos(psi)*cos(theta), cos(theta)*sin(psi), -sin(theta), 0, 0, 0],
         [cos(psi)*sin(phi)*sin(theta) - cos(phi)*sin(psi), cos(phi)*cos(psi) + sin(phi)*sin(psi)*sin(theta), cos(theta)*sin(phi), 0, 0, 0],
         [sin(phi)*sin(psi) + cos(phi)*cos(psi)*sin(theta), cos(phi)*sin(psi)*sin(theta) - cos(psi)*sin(phi), cos(phi)*cos(theta), 0, 0, 0],
         [0, 0, 0, 1, 0, -sin(theta)],
         [0, 0, 0, 0, cos(phi), cos(theta)*sin(phi)],
         [0, 0, 0, 0, -sin(phi), cos(phi)*cos(theta)]])

        self.state["x"], self.state["y"], self.state["z"], self.state["phi"], self.state["theta"], self.state["psi"]  = np.dot(self.transfomration_matrix, np.array([x, y, z, phi, theta, psi]))


    def pose_callback(self, msg):
        x = msg.pose.position.x
        y = msg.pose.position.y
        z = msg.pose.position.z
        
        quaternion = [msg.pose.orientation.x, msg.pose.orientation.y, msg.pose.orientation.z, msg.pose.orientation.w]
        phi, theta, psi = tf.transformations.euler_from_quaternion(quaternion, 'sxyz')

        self.pose_ref["x"], self.pose_ref["y"], self.pose_ref["z"], self.pose_ref["phi"], self.pose_ref["theta"], self.pose_ref["psi"]  = np.dot(self.transfomration_matrix, np.array([x, y, z, phi, theta, psi]))

    def meas_pub(self):
        for dof in self.dof_name:
            self.pubs[dof].publish(self.state[dof])

    def ref_pub(self):
        for dof in self.dof_name:
            self.pose_pubs[dof].publish(self.pose_ref[dof])


if __name__ == "__main__":
    
    rospy.init_node('position_controller_adaptor')
    position_controller_adaptor = PositionControllerAdaptor()

    rate = rospy.Rate(50)

    while not rospy.is_shutdown():
        position_controller_adaptor.meas_pub()
        position_controller_adaptor.ref_pub()
        rate.sleep()